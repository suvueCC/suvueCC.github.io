---
layout: post
title:  "依赖倒置原则"
categories: 软件架构设计原则
tags: Spring内功心法
author: Zk1an
---

* content
{:toc}

## 学习是人类进步的阶梯
Tom非常热爱编程，目前正在学习Java课程和python课程。   
![tom学习中](../uPic/%202020%2007%2011%2015%2054IDELXo.jpg)
来调用一下：
![main方法第一次调用](../uPic/%202020%2007%2011%2016%2002HqsDDd.jpg)
OK，没问题！
但是年轻人的好奇心总是强烈的，随着学到的知识越多，现在Tom还想学习AI(人工智能)的课程，这时候我们要修改代码了。
在Tom类增加studyAICourse()方法，在main()中也要追加方法调用：
![添加了AI课程](../uPic/%202020%2007%2011%2016%2013hbhxpY.jpg)
如此一来，系统发布之后，实际上是非常不稳定的，在修改代码的同时，也会带来意想不到的风险。
## 依赖倒置原则是什么？
依赖倒置原则是指设计代码结构时，高层模块不应依赖低层模块，二者都应依赖其抽象。抽象不应该依赖于细节，反过来细节应该依赖抽象。
## 代码实践  
- 我们接着上面的代码进行优化，先创建一个课程的抽象ICourse接口：
![ICourse接口](../uPic/%202020%2007%2011%2021%2043qVdXb5.jpg)
- 然后编写JavaCourse类：
![JavaCourse类](../uPic/%202020%2007%2011%2021%2046OCGLCZ.jpg)
- 再实现PythonCourse类：
![PythonCourse类](../uPic/%202020%2007%2011%2021%2049b3OKGA.jpg)
- 修改Tom类：
![修改后的Tom类](../uPic/%202020%2007%2011%2021%2052OiQ1P6.jpg)
- 来看调用代码：
![调用代码](../uPic/%202020%2007%2011%2021%2056nQDAGx.jpg)
- 这时候再来看代码，Tom的兴趣无论多么广泛，对于新的课程，只需新建一个类，通过传参的方式告诉Tom,而不需要修改底层(Tom类)代码，
实际上这是一种大家非常熟悉的方式，叫做**依赖注入**,注入的方式还有构造器方式和Setter方式，我们来看构造器注入方式：
![202007112204ewrVuM](../uPic/%202020%2007%2011%2022%2004ewrVuM.jpg)
- 看调用代码：  
![202007112206TfGsv2](../uPic/%202020%2007%2011%2022%2006TfGsv2.jpg)
- **根据构造器注入，在调用时每次都要创建实例。** 如果Tom是全局单例，则我们就要选择Setter方式来注入，继续修改Tom类的代码：
![2020071122108zW8IL](../uPic/%202020%2007%2011%2022%20108zW8IL.jpg)
- 看调用代码：  
![202007112215ji3Fam](../uPic/%202020%2007%2011%2022%2015ji3Fam.jpg)
- 最后我们来看最终的类图：
![202007112234AICourse](../uPic/%202020%2007%2011%2022%2034AICourse.png)
## 遵循开闭原则的好处
- 通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性提高代码的可读性和可维护性，并且能够降低修改程序所造成的风险。
- 大家要切记：以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此在拿到需求之后，要面向接口编程，先顶层再细节地设计代码结构。
